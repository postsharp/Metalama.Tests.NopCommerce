using Metalama.Aspects;
using Metalama.Framework.Aspects;
using Metalama.Framework.Code;
using Metalama.Framework.Fabrics;

#if !BENCHMARK

/*
 * IMPORTANT: Templates should not create string literals that depend on names/display strings.
 *            Nop.Web (and Razor in general) is creating lot of literals and runs close to the 16Mb limit of #US PE stream.
 */

[assembly: AspectOrder(
    typeof(UninlineableOverrideAspect),
    typeof(ForcedJumpOverrideAspect),
    typeof(LoggingAspect),
    typeof(OverridePropertyAttribute),
    typeof(OverrideFinalizerAttribute),
    typeof(OverrideEventAttribute),
    typeof(MethodIntroductionAttribute),
    typeof(FieldIntroductionAttribute),
    typeof(PropertyIntroductionAttribute),
    typeof(InterfaceIntroductionAttribute))]


namespace Metalama.Aspects
{
    #region other issues
    // Libraries\Nop.Core\Caching\DistributedCacheManager throws error on VSX preview
    #endregion

    #region Helpers
    [CompileTime]
    public static class HelperExtensions
    {
        public static void AddAspects<T>(this IAspectReceiver<T> aspectReceiver, params IAspect<T>[] aspects)
            where T : class, IDeclaration
        {
            foreach(var aspect in aspects)
            {
                aspectReceiver.AddAspect(aspect.GetType(), _ => aspect);
            }
        }
    }
    #endregion

    #region Runtime

    public static class AspectLog
    {
        public static void Write(string s)
        {            
            // This makes sure the aspect code does not write to console, which seems to retain memory in tests.
        }
    }

    #endregion

    #region fabrics

    public class MethodFabric : TransitiveProjectFabric
    {
        public override void AmendProject(IProjectAmender amender)
        {
            #region fixed and working
            /* Fixed and working tests */

            // FIXED - Error LAMA0611: Error CS8648 in code generated by Metalama: A goto cannot jump to a location after a using declaration.
            // FIXED - Error LAMA0041: 'FabricAspect.OverrideMethod()' threw 'AssertionFailedException' when applied to X
            // FIXED - error CS1061: 'TEntity' does not contain a definition for 'Id' and no accessible extension method 'Id' accepting a first argument of type 'TEntity' could be found (are you missing a using directive or an assembly reference?)
            // FIXED - error CS0452: The type 'TEntity' must be a reference type in order to use it as parameter 'T' in the generic type or method 'DataConnection.GetTable<T>()'
            amender.Outbound.SelectMany(p => p.Types.SelectMany(t => t.Methods).Where(m => !m.IsAsync && !m.IsAbstract && !m.IsImplicitlyDeclared))
                .AddAspects(new ForcedJumpOverrideAspect(), new UninlineableOverrideAspect());

            amender.Outbound.SelectMany(p => p.Types.SelectMany(t => t.Methods).Where(m => m.IsAsync && !m.IsGeneric))
                .AddAspects(new ForcedJumpOverrideAspect(), new UninlineableOverrideAspect());

            // FIXED - error LAMA0611: Error CS0140 in code generated by Metalama: The label '__aspect_return_1' is a duplicate
            amender
               .Outbound.SelectMany(p => p.Types.SelectMany(t => t.Methods).Where(m => 
                    !m.IsAbstract 
                    && !m.IsImplicitlyDeclared
                    && m.GetIteratorInfo() is {IsIteratorMethod: false, EnumerableKind: not EnumerableKind.IAsyncEnumerable and not EnumerableKind.IAsyncEnumerator} ))
               .AddAspect<LoggingAspect>();

            // Contracts.
            amender
                .Outbound.SelectMany(p => 
                    p.Types
                    .SelectMany( t => t.Methods )
                    .Where(m => !m.IsImplicitlyDeclared )
                    .Where(m => m is not { IsPartial: true, HasImplementation: false } )
                    .Where(m => m.ReturnType != TypeFactory.GetType(SpecialType.Void) && m.GetAsyncInfo().ResultType != TypeFactory.GetType(SpecialType.Void) ) 
                    .Where(m => m.GetIteratorInfo() is not {IsIteratorMethod: true, EnumerableKind: EnumerableKind.IAsyncEnumerable } )
                    .Select(m => m.ReturnParameter))
                .AddAspectIfEligible<ParameterContract>();

            amender
                .Outbound.SelectMany(p => 
                    p.Types
                    .SelectMany( t => 
                        t.Methods
                        .Where(m => m is not { IsPartial: true, HasImplementation: false } )
                        .Where(m => !m.IsImplicitlyDeclared ) )
                    .SelectMany(m => m.Parameters))
                .AddAspectIfEligible<ParameterContract>();
               
            #endregion

            #region errors
            /* Tests causing errors */
            
            // Using LoggingAspect on IAsyncEnumerable/Enumerator methods (bug #31108).
            // amender
            //    .With(p => p.Types.SelectMany(t => t.Methods).Where(m => 
            //         !m.IsAbstract 
            //         && !m.IsImplicitlyDeclared
            //         && m.GetIteratorInfo() is {EnumerableKind: EnumerableKind.IAsyncEnumerable or EnumerableKind.IAsyncEnumerator} 
            //         && !m.GetAsyncInfo().IsAwaitable))
            //    .AddAspect<LoggingAspect>();

            #endregion
        }
    }

    public class PropertiesFabric : TransitiveProjectFabric
    {
        public override void AmendProject(IProjectAmender amender)
        {
            #region fixed and/or working
            /* Fixed and working tests */

            amender.Outbound.SelectMany(p =>
                p.Types.SelectMany(t => t.Properties)
                .Where(it => it is not { IsOverride: true, OverriddenProperty: { IsAbstract: true, GetMethod: not null, SetMethod: null } })
                .Where(it => it.DeclaringType is not { TypeKind: TypeKind.Interface })
                .Where(it => !it.IsAbstract && !it.IsImplicitlyDeclared))
            .AddAspect<OverridePropertyAttribute>();

            // FIXED 
            amender.Outbound.SelectMany(p =>
                p.Types.SelectMany(t => t.Properties)
                .Where(it => it is { IsOverride: true, OverriddenProperty: { IsAbstract: true, GetMethod: not null, SetMethod: null } })
                .Where(it => it.DeclaringType is not { TypeKind: TypeKind.Interface })
                .Where(it => !it.IsAbstract && !it.IsImplicitlyDeclared))
            .AddAspect<OverridePropertyAttribute>();

            // FIXED
            amender.Outbound.SelectMany(p =>
                p.Types.SelectMany(t => t.Properties)
                .Where(it => !it.IsAbstract && !it.IsImplicitlyDeclared)
                .Where(it => it.DeclaringType is { TypeKind: TypeKind.Interface }))
            .AddAspect<OverridePropertyAttribute>();
                           
            // Method aspects on property accessors.
            amender
                .Outbound.SelectMany(p => 
                    p.Types.SelectMany(t => t.Properties )
                    .SelectMany(p => new [] {p.GetMethod!, p.SetMethod! }.Where(m => m != null))
                    .Where(m => !m.IsAbstract && !m.IsImplicitlyDeclared))
                .AddAspects(new LoggingAspect(), new ForcedJumpOverrideAspect(), new UninlineableOverrideAspect());

            // Contracts on properties
            amender
                .Outbound.SelectMany(p => 
                    p.Types.SelectMany(t => t.Properties )
                    .Where(m => !m.IsAbstract && !m.IsImplicitlyDeclared))
                    .Where(it => it.GetMethod == null || it.GetMethod.GetIteratorInfo().EnumerableKind == EnumerableKind.None)
                .AddAspect<FieldOrPropertyContract>();

            #endregion

            #region errors
            /* Tests causing errors */
            #endregion
        }
    }

    public class FieldsFabric : TransitiveProjectFabric
    {
        public override void AmendProject(IProjectAmender amender)
        {
            #region fixed and/or working
            /* Fixed and working tests */

            // FIXED: CSC : error LAMA0001: Unexpected exception occurred in Metalama: Exception of type 'Metalama.Framework.Engine.AssertionFailedException' was thrown.
            amender
                .Outbound.SelectMany(p =>
                    p.Types.SelectMany(t => t.Fields)
                    .Where(it => !it.IsAbstract && !it.IsImplicitlyDeclared)
                    .Where(it => it is not IField { Writeability: Writeability.None })
                    .Where(it => it.DeclaringType is not { TypeKind: TypeKind.Enum or TypeKind.Interface }))
                .AddAspect<OverridePropertyAttribute>();

            amender
                .Outbound.SelectMany(p => 
                    p.Types.SelectMany(t => t.Fields )
                    .SelectMany(p => new [] {p.GetMethod!, p.SetMethod! }.Where(m => m != null))
                    .Where(m => !m.IsAbstract && !m.IsImplicitlyDeclared)
                    .Where(it => it is not IField { Writeability: Writeability.None })
                    .Where(it => it.DeclaringType is not { TypeKind: TypeKind.Enum or TypeKind.Interface }))
                .AddAspects(new LoggingAspect(), new ForcedJumpOverrideAspect(), new UninlineableOverrideAspect());

            // Contracts on fields
            amender
                .Outbound.SelectMany(p => 
                    p.Types.SelectMany(t => t.Fields )
                    .Where(it => !it.IsAbstract && !it.IsImplicitlyDeclared)
                    .Where(it => it is not IField { Writeability: Writeability.None })
                    .Where(it => it.GetMethod!.GetIteratorInfo().EnumerableKind == EnumerableKind.None)
                    .Where(it => it.DeclaringType is not { TypeKind: TypeKind.Enum or TypeKind.Interface }))
                .AddAspect<FieldOrPropertyContract>();

            #endregion

            #region errors
            #endregion
        }
    }

    public class EventsFabric : TransitiveProjectFabric
    {
        public override void AmendProject(IProjectAmender amender)
        {
            amender.Outbound.SelectMany(p => p.Types.SelectMany(t => t.Events).Where(e => !e.IsImplicitlyDeclared)).AddAspect<OverrideEventAttribute>();

            // Method aspects on event accessors.
            amender
                .Outbound.SelectMany(p => 
                    p.Types.SelectMany(t => t.Events )
                    .SelectMany(p => new [] {p.AddMethod!, p.RemoveMethod! }.Where(m => m != null))
                    .Where(m => !m.IsAbstract && !m.IsImplicitlyDeclared))
                .AddAspects(new LoggingAspect(), new ForcedJumpOverrideAspect(), new UninlineableOverrideAspect());
        }
    }

    public class InterfaceFabric : TransitiveProjectFabric
    {
        public override void AmendProject(IProjectAmender amender)
        {
            #region fixed and/or working
            /* Fixed and working tests */


            // FIXED - CSC : error LAMA0001: Unexpected exception occurred in Metalama: Exception of type 'Metalama.Framework.Engine.AssertionFailedException' was thrown.
            amender.Outbound.SelectMany(p =>
                p.Types
                .Where(t => !t.IsStatic)
                .Where(t => t is not { TypeKind: TypeKind.Enum or TypeKind.Interface or TypeKind.Delegate })
                .Where(t => t.Name != "Program")) // This suppresses global statements.
            .AddAspect<InterfaceIntroductionAttribute>();

            #endregion

            #region errors
            /* Tests causing errors */

            // CSC : error LAMA0001: Unexpected exception occurred in Metalama: Exception of type 'Metalama.Framework.Engine.AssertionFailedException' was thrown.
            // (caused by global statements)
            //amender.With(p => 
            //    p.Types
            //    .Where(t => !t.IsStatic)
            //    .Where(t => t is not { TypeKind: TypeKind.Enum or TypeKind.Interface or TypeKind.Delegate } ) 
            //    .Where(t => t.Name == "Program" )) // This suppresses global statements.
            //.AddAspect<InterfaceIntroductionAttribute>();

            #endregion
        }
    }

    public class IntroductionFabric : TransitiveProjectFabric
    {
        public override void AmendProject(IProjectAmender amender)
        {
            amender.Outbound.SelectMany(p => 
                p.Types
                .Where(t => t.TypeKind is not (TypeKind.Interface or TypeKind.Enum or TypeKind.Delegate) && !t.IsImplicitlyDeclared))
                .AddAspect<FieldIntroductionAttribute>();

            amender.Outbound.SelectMany(p => 
                p.Types
                .Where(t => t.TypeKind is not (TypeKind.Interface or TypeKind.Enum or TypeKind.Delegate) && !t.IsImplicitlyDeclared))
                .AddAspect<MethodIntroductionAttribute>();

            amender.Outbound.SelectMany(p => 
                p.Types
                .Where(t => t.TypeKind is not (TypeKind.Interface or TypeKind.Enum or TypeKind.Delegate) && !t.IsImplicitlyDeclared))
                .AddAspect<PropertyIntroductionAttribute>();

            amender.Outbound.SelectMany(p => 
                p.Types
                .Where(t => t.TypeKind is not (TypeKind.Interface or TypeKind.Enum or TypeKind.Delegate) && !t.IsImplicitlyDeclared))
                .AddAspect<EventIntroductionAttribute>();
        }
    }

    #endregion


    [CompileTime]
    public class IntroductionHelper
    {
        [CompileTime]
        public static bool IsSkipped(IType type)
        {
            // Introductions should skip these types because there are tests that check fields and properties.
            var skippedTypes =
                new[]
                {
                    "Nop.Core.BaseEntity",
                    "Nop.Web.Framework.Models.BaseNopModel",
                    "Nop.Core.Configuration.ISettings",
                    "Nop.Core.Configuration.IConfig"
                }.Select(n =>
                {
                    try
                    {
                        return TypeFactory.GetType(n);
                    }
                    catch
                    {
                        return null;
                    }
                }
                );

            return skippedTypes.Any(t => t == null || type.Is(t));
        }
    }

    #region introduction aspects
    public class FieldIntroductionAttribute : TypeAspect
    {
        public override void BuildAspect(IAspectBuilder<INamedType> builder)
        {
            if (!builder.Target.IsStatic 
                && !builder.Target.AllMembers().Any(m => m.Name == nameof(IntroducedField))
                && !IntroductionHelper.IsSkipped(builder.Target))
            {
                builder.Advice.IntroduceField(builder.Target, nameof(IntroducedField), whenExists: OverrideStrategy.Ignore);
            }

            if (!builder.Target.AllMembers().Any(m => m.Name == nameof(IntroducedField_Static)))
            {
                builder.Advice.IntroduceField(builder.Target, nameof(IntroducedField_Static), whenExists: OverrideStrategy.Ignore);
            }
        }

        [Template]
        public int IntroducedField = 42;

        [Template]
        public static int IntroducedField_Static = 42;
    }

    public class PropertyIntroductionAttribute : TypeAspect
    {
        public override void BuildAspect(IAspectBuilder<INamedType> builder)
        {
            if (!builder.Target.IsStatic
                && !IntroductionHelper.IsSkipped(builder.Target))
            {
                if (!builder.Target.AllMembers().Any(m => m.Name == nameof(IntroducedProperty)))
                {
                    builder.Advice.IntroduceProperty(builder.Target, nameof(IntroducedProperty), whenExists: OverrideStrategy.Ignore);
                }
                
                if (!builder.Target.AllMembers().Any(m => m.Name == nameof(IntroducedGetOnlyProperty)))
                {
                    builder.Advice.IntroduceProperty(builder.Target, nameof(IntroducedGetOnlyProperty), whenExists: OverrideStrategy.Ignore);
                }
            }

            if (!builder.Target.AllMembers().Any(m => m.Name == nameof(IntroducedStaticProperty)))
            {
                builder.Advice.IntroduceProperty(builder.Target, nameof(IntroducedStaticProperty), whenExists: OverrideStrategy.Ignore);
            }
        }

        [Template]
        public int IntroducedProperty { get; set; } = 42;

        [Template]
        public int IntroducedGetOnlyProperty { get; } = 42;

        [Template]
        public static int IntroducedStaticProperty { get; set; } = 42;
    }

    public class EventIntroductionAttribute : TypeAspect
    {
        public override void BuildAspect(IAspectBuilder<INamedType> builder)
        {
            if (!builder.Target.IsStatic)
            {
                if (!builder.Target.AllMembers().Any(m => m.Name == nameof(IntroducedEvent)))
                {
                    builder.Advice.IntroduceEvent(builder.Target, nameof(IntroducedEvent), whenExists: OverrideStrategy.Ignore);
                }
                
                if (!builder.Target.AllMembers().Any(m => m.Name == nameof(IntroducedEventField)))
                {
                    builder.Advice.IntroduceEvent(builder.Target, nameof(IntroducedEventField), whenExists: OverrideStrategy.Ignore);
                }
            }
        }

        [Template]
        public event EventHandler IntroducedEvent
        {
            add
            {
            }

            remove
            {
            }
        }

        [Template]
        public event EventHandler IntroducedEventField;
    }

    public class MethodIntroductionAttribute : TypeAspect
    {
        public override void BuildAspect(IAspectBuilder<INamedType> builder)
        {
            if (!builder.Target.IsStatic)
            {
                builder.Advice.IntroduceMethod(builder.Target, nameof(IntroducedMethod), whenExists: OverrideStrategy.Ignore);
            }

            if (!builder.Target.IsStatic && !builder.Target.IsSealed && builder.Target is not { TypeKind: TypeKind.Struct or TypeKind.RecordStruct} )
            {
                builder.Advice.IntroduceMethod(builder.Target, nameof(IntroducedMethod_Virtual), whenExists: OverrideStrategy.Ignore);
            }

            builder.Advice.IntroduceMethod(builder.Target, nameof(IntroducedMethod_Static), whenExists: OverrideStrategy.Ignore);
        }

        [Template]
        public T IntroducedMethod<T>(T x)
        {
            AspectLog.Write("This is introduced method.");
            return meta.Proceed();
        }

        [Template]
        public static int IntroducedMethod_Static()
        {
            AspectLog.Write("This is introduced method.");

            return meta.Proceed();
        }

        [Template]
        public int IntroducedMethod_Virtual()
        {
            AspectLog.Write("This is introduced method.");

            return meta.Proceed();
        }
    }

    public interface IIntroducedInterface
    {
        int InterfaceMethod();

        event EventHandler InterfaceEvent;

        event EventHandler? InterfaceEventField;

        int Property { get; set; }

        string? AutoProperty { get; set; }
    }

    public class InterfaceIntroductionAttribute : TypeAspect
    {
        public override void BuildAspect(IAspectBuilder<INamedType> builder)
        {
            builder.Advice.ImplementInterface(builder.Target, typeof(IIntroducedInterface), whenExists: OverrideStrategy.Ignore );
        }

        [InterfaceMember(IsExplicit = true)]
        public int InterfaceMethod()
        {
            AspectLog.Write("This is introduced interface member.");
            return meta.Proceed();
        }

        [InterfaceMember(IsExplicit = true)]
        public event EventHandler? InterfaceEvent
        {
            add
            {
                AspectLog.Write("This is introduced interface member.");
                meta.Proceed();
            }

            remove
            {
                AspectLog.Write("This is introduced interface member.");
                meta.Proceed();
            }
        }

        [InterfaceMember(IsExplicit = true)]
        public event EventHandler? InterfaceEventField = default;

        [InterfaceMember(IsExplicit = true)]
        public int Property
        {
            get
            {
                AspectLog.Write("This is introduced interface member.");

                return meta.Proceed();
            }

            set
            {
                AspectLog.Write("This is introduced interface member.");
                meta.Proceed();
            }
        }

        [InterfaceMember(IsExplicit = true)]
        public string? AutoProperty { get; set; } = default;
    }

    #endregion

    #region override aspects

    public class LoggingAspect : OverrideMethodAspect
    {
        public override dynamic? OverrideMethod()
        {
            try
            {
                var result = meta.Proceed();

                AspectLog.Write($"Logging: executing");
                var parameters = meta.Target.Parameters;

                if (parameters.Count > 0)
                {
                    foreach (var parameter in parameters)
                    {
                        AspectLog.Write($"Logging: Method has parameter {parameter.Name} of type {parameter.Type} with {parameter.DefaultValue} default value.");
                    }
                    return result;
                }
                else
                {
                    AspectLog.Write("Logging: parameterless method.");
                    return result;
                }
            }
            catch ( Exception e )
            {
                AspectLog.Write($"Logging: caught exception {e.Message}");
                throw;
            }
        }
    }

    public class OverridePropertyAttribute : OverrideFieldOrPropertyAspect
    {
        public override dynamic? OverrideProperty
        {
            get
            {
                AspectLog.Write("This is the overridden getter.");
                return meta.Proceed();
            }

            set
            {
                AspectLog.Write($"This is the overridden setter.");
                meta.Proceed();
            }
        }
    }

    public class OverrideEventAttribute : OverrideEventAspect
    {
        public override void OverrideAdd(dynamic value)
        {
            AspectLog.Write("Overridden add.");
            meta.Proceed();
        }

        public override void OverrideRemove(dynamic value)
        {
            AspectLog.Write("Overridden remove.");
            meta.Proceed();
        }
    }

    public class OverrideFinalizerAttribute : TypeAspect
    {
        public override void BuildAspect(IAspectBuilder<INamedType> builder)
        {
            var introductionResult = builder.Advice.IntroduceFinalizer(builder.Target, nameof(IntroduceTemplate), whenExists: OverrideStrategy.Override);
        }

        [Template]
        public dynamic? IntroduceTemplate()
        {
            AspectLog.Write("This is the introduction.");
            return meta.Proceed();
        }
    }    
    
    public class UninlineableOverrideAspect : OverrideMethodAspect
    {
        public override dynamic? OverrideMethod()
        {
            if (meta.RunTime(Random.Shared.Next()) == 0)
            {
                AspectLog.Write($"Uninlineable: randomly");
                return meta.Proceed();
            }
            else
            {
                AspectLog.Write($"Uninlineable: normally");
                return meta.Proceed();
            }
        }
    }
    
    public class ForcedJumpOverrideAspect : OverrideMethodAspect
    {
        public override dynamic? OverrideMethod()
        {
            var x = meta.Proceed();

            if (meta.RunTime(Random.Shared.Next()) == 0)
            {
                AspectLog.Write($"ForcedJump: randomly");
                return x;
            }

            AspectLog.Write($"ForcedJump: normally");
            return x;
        }
    }

    #endregion

    #region Contracts

    public class ParameterContract : ContractAspect
    {
        public override void Validate( dynamic? value )
        {
            AspectLog.Write($"Contract on {meta.Target.Parameter.Name}");
        }
    }

    public class FieldOrPropertyContract : ContractAspect
    {
        public override void Validate( dynamic? value )
        {
            AspectLog.Write($"Contract on {meta.Target.FieldOrPropertyOrIndexer.Name}");
        }
    }

    #endregion
}

#endif